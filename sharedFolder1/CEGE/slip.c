#include <stdio.h>
#include <stdio.h>
#include <mc1322x.h>
#include <board.h>
#include "contiki.h"
#include "contiki-uart.h"
#include "slip.h"

/* SLIP special character codes
*/
#define END             0300    /* indicates end of packet */
#define ESC             0333    /* indicates byte stuffing */
#define ESC_END         0334    /* ESC ESC_END means END data byte */
#define ESC_ESC         0335    /* ESC ESC_ESC means ESC data byte */

void set_fletcher_chk(uint8_t *buffer, uint8_t len, uint8_t *chk_a, uint8_t *chk_b);
uint8_t check_fletcher_chk(uint8_t *buffer, uint8_t len);


/*---------------------------------------------------------------------------*/
// slip code
//

/*
 * The code here is derived directly from:
 * "A NONSTANDARD FOR TRANSMISSION OF IP DATAGRAMS OVER SERIAL LINES: SLIP"
 * RFC 1055
 *  
 * It's a simple serial line driver to allow the transmission of arbitrary
 * binary code over a serial line, in which packets are delimited by END
 * characters. If an END appears in the binary, it is escaped, using an ESC
 * charater - and if the ESC character appears it also is escaped.
 *
 * Extended with a simple CRC check at the end of every packet.
 *
 */

// Send a character on UART2
inline void send_char(char ch)
{
  uart2_putc(ch);
}

// Receive a character from UART2, blocking until one appears
inline char recv_char()
{
  // Loop until we can get a character
  //
  while (!uart2_can_get())
		;

  char ch;
  ch = uart2_getc();

  return (ch);
}

/* 
 * SEND_PACKET: sends a packet of length "len", starting at
 * location "p".
 */
void send_packet(char *p, int len)
{
  // Calculate the Fletcher check for sending later
  //
  uint8_t a, b;
  set_fletcher_chk(p, len, &a, &b);  

	// send an initial END character to flush out any data that may
	// have accumulated in the receiver due to line noise
	//
  send_char(END);

	// for each byte in the packet, send the appropriate character
  // sequence
  //
  while (len--) {
		switch(*p) {
			// if it's the same code as an END character, we send a
			// special two character code so as not to make the
			// receiver think we sent an END
			//
			case END:
				send_char(ESC);
				send_char(ESC_END);
				break;

			// if it's the same code as an ESC character,
			// we send a special two character code so as not
			// to make the receiver think we sent an ESC
			//
			case ESC:
				send_char(ESC);
				send_char(ESC_ESC);
				break;

			// otherwise, we just send the character
			//
			default:
				send_char(*p);
		}

		p++;
	}


  send_char(a);
  send_char(b);

	// tell the receiver that we're done sending the packet
	//
	send_char(END);
}


/* 
 * RECV_PACKET: receives a packet into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int recv_packet(char *p, int len)
{
	char c;
	int received = 0;

	// sit in a loop reading bytes until we put together
	// a whole packet.
	// Make sure not to copy them into the packet if we
	// run out of room.
	//
	while(1) {
		// get a character to process
		//
		c = recv_char();

		// handle bytestuffing if necessary
		//
		switch (c) {
			// if it's an END character then we're done with
			// the packet
			//
			case END:
				// a minor optimization: if there is no
				// data in the packet, ignore it. This is
				// meant to avoid bothering IP with all
				// the empty packets generated by the
				// duplicate END characters which are in
				// turn sent to try to detect line noise.
				//
				if (received != 0) {
					// See if the Fletcher check matches. If not, return -1
		      //
					if (!check_fletcher_chk(p, received))
						return (-1);

					return (received-2);
        }
				else
					break;

			// if it's the same code as an ESC character, wait
			// and get another character and then figure out
			// what to store in the packet based on that.
			//
			case ESC:
				c = recv_char();

				// if "c" is not one of these two, then we
				// have a protocol violation.  The best bet
				// seems to be to leave the byte alone and
				// just stuff it into the packet
				//
				switch(c) {
					case ESC_END:
						c = END;
						break;
					case ESC_ESC:
						c = ESC;
						break;
				}

			// here we fall into the default handler and let
			// it store the character for us
			//
			default:
				if (received < len)
					p[received++] = c;
				}
		}
 }


void set_fletcher_chk(uint8_t *buffer, uint8_t len, uint8_t *chk_a, uint8_t *chk_b)
{
	uint8_t a = 0;
	uint8_t b = 0;
	uint8_t i = 0;

	for (i = 0; i < len; i++) {
		a += buffer[i];
		b += a;
	}

	*chk_a = a;
	*chk_b = b;
}


uint8_t check_fletcher_chk(uint8_t *buffer, uint8_t len)
{
	uint8_t a = 0;
	uint8_t b = 0;

  set_fletcher_chk(buffer, len-2, &a, &b);

	if ((a == buffer[len-2]) && (b == buffer[len-1]))
    return 1;
	else
    return 0;
}

/*---------------------------------------------------------------------------*/
